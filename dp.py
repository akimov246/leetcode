from functools import cache
import timeit

@cache
def f(n):
    if n == 0 or n == 1:
        return 1
    return f(n - 1) + f(n - 2)

def fdp(n):
    a = 1 # f(i - 2)
    b = 1 # f(i - 1)
    for i in range(2, n + 1):
        a, b = b, a + b
    return b

print(f(70))
print(fdp(70))

# Динамическое программирование и задача о воришке.
'''
Вор, который собирается ограбить целый квартал домов. В каждом i-том доме есть чем поживиться (ценность имущества - vi). 
Однако системы безопасности домов связаны между собой, и если вор попытается ограбить соседние дома, сработает сигнализация.
'''
# Определение подзадач
'''
Самый первый и важный шаг в решении любой задачи динамического программирования – определение подпроблем.
Для любого i-того дома есть две альтернативы:
> ограбить его. Но после этого увеличить выгоду вы можете только в доме i-2, так как i-1 теперь для вас закрыт. 
В этом случае к текущей сумме добавляется значение vi.

> пропустить его. Теперь вы можете переходить к дому i-1, он доступен для ограбления. 
Но к текущей сумме ничего не добавляется.
'''

# Определение рекуррентного отношения
'''
Необходимо четко оформить вышеизложенные размышления в виде функции со следующими свойствами:
> Она должна идентифицироваться по некоторым целочисленным входным данным. 
Это позволит связать вход с вычисленным результатом и выполнять вычисления в определенном порядке.

> Решение должно быть легко извлекаемо, иначе функция не имеет для нас никакой пользы.

> Функция должна основываться сама на себе.

Это и есть рекуррентное отношение – выражение одних членов последовательности через другие.

Вот такую формулу мы получаем для задачи о воришке:
f(i) = max(f(i - 2) + vi, f(i - 1)), где
f(i) - максимальная прибыль, которую можно получить, ограбив дома с 0 по i.
'''

def house_robber(house_values):
    a = 0 # f(i - 2)
    b = 0 # f(i - 1)
    for val in house_values:
        a, b = b, max(b, a + val)
    return b

print(house_robber([3, 10, 3, 1, 2]))

# Динамическое программирование и задача о размене монет
'''
 у вас есть несколько номиналов (d1, d2, …, dn) и неограниченное количество монет каждого номинала. 
 С их помощью нужно набрать определенную сумму c. Суть задачи – использовать как можно меньше монет.
 Суть задачи – использовать как можно меньше монет.
'''